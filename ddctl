#!/usr/bin/env python3
from datadog import initialize, api
from sys import argv
from argparse import ArgumentParser
from pathlib import Path

# Setting up parser
parser = ArgumentParser()
parser.add_argument("--config",
                    help="declare path to your ddctl.conf config file",
                    metavar="FILE", default="ddctl.conf")
parser.add_argument("--host-query", metavar='QUERY',
                    help="ask datadog for a list of hosts by query",
                    default="_empty_")
parser.add_argument("--tags-by-host", metavar='HOST',
                    help="ask datadog for a list of tags by host",
                    default="_empty_")
parser.add_argument("--get-all-tags", action="store_true",
                    help="get all tags in your environment",
                    default="_empty_")
parser.add_argument("--host", metavar='HOSTS,...',
                    help="hostname to mute or unmute. \
                    Comma ',' seperated list for multiple",
                    default="_empty_")
parser.add_argument("--scope", metavar='TAGS,...',
                    help="scope by tag(s) to schedule downtime. \
                    Comma ',' seperated list for multiple",
                    default="_empty_")
parser.add_argument("--csv", help="flag to return list with comma seperation",
                    action="store_true", default=False)
parser.add_argument("--force", help="flag to force downtime of host(s) mute",
                    action="store_true", default=False)
parser.add_argument("--hours", help="how many hour(s) to mute",
                    type=int, default=2)
parser.add_argument("--id", help="downtime id to delete",
                    type=int, default=0)
parser.add_argument("--forever", action="store_true",
                    help="set no end time for mute, this overrides --hours",
                    default=False)
parser.add_argument("--mute", action="store_true",
                    help="mute host and schedule downtime",
                    default="_empty_")
parser.add_argument("--unmute", action="store_true",
                    help="UNmute host and return to normal monitoring",
                    default="_empty_")
parser.add_argument("--add-downtime", action="store_true",
                    help="schedule downtime by scope",
                    default="_empty_")
parser.add_argument("--list-my-downtimes", action="store_true",
                    help="list scheduled downtimes owned by you",
                    default="_empty_")
parser.add_argument("--list-all-downtimes", action="store_true",
                    help="list scheduled downtimes owned by anyone",
                    default="_empty_")
parser.add_argument("--remove-downtime", action="store_true",
                    help="remove scheduled downtime by id",
                    default="_empty_")
args = parser.parse_args()

def api_initialization(config_file):
    # imports
    from configparser import ConfigParser
    # Pulling in API and APP Token from config
    try:
        config_file_check = Path(config_file)
        if config_file_check.is_file():
            config = ConfigParser()
            config.read(config_file)
            api_key  = config['ddctl']['api_key']
            app_key  = config['ddctl']['app_key']
            dd_login = config['ddctl']['dd_login']
        else:
            raise SystemExit("Config file not found at {}".format(config_file))
    except Exception as err:
        raise SystemExit("I am having a problem reading {} in the config.".format(err))
    # Initialize the connection
    options = {'api_key': api_key, 'app_key': app_key}
    try:
        initialize(**options)
    except Exception as err:
        raise SystemExit("Unable to initialize due to: {}".format(err))
    return dd_login

def hours_from_now(num_hours):
    # imports
    from datetime import datetime, timedelta
    # Return POSIX timestamp for number hours specified
    how_many_hours_from_now = datetime.now() + timedelta(hours=num_hours)
    return '{:%s}'.format(how_many_hours_from_now)

def mute_host(hostname, FOREVER=False, ENDHOURS=2, FORCE=False):
    # Test to see if FOREVER and/or ENDHOURS is requested
    if args.forever:
        FOREVER=True
    if args.hours is not 2:
        ENDHOURS=args.hours
    if args.force:
        FORCE=True
    # Initialize API for use and grab requestor
    dd_login = api_initialization(args.config)
    # Mute the host by hostname
    for host in hostname.split(','):
        if host == "":
            continue
        if FOREVER:
            try:
                if FORCE:
                    result = api.Host.mute(host,
                            message="scheduled by ddctl for {}".format(dd_login),
                            override=True)
                else:
                    result = api.Host.mute(host,
                            message="scheduled by ddctl for {}".format(dd_login))
            except Exception as err:
                raise SystemExit("Unable to mute {0} due to: {1}".format(host, err))
        else:
            try:
                if FORCE:
                    result = api.Host.mute(host, end=hours_from_now(ENDHOURS),
                            message="scheduled by ddctl for {}".format(dd_login),
                            override=True)
                else:
                    result = api.Host.mute(host, end=hours_from_now(ENDHOURS),
                            message="scheduled by ddctl for {}".format(dd_login))
            except Exception as err:
                raise SystemExit("Unable to mute {0} due to: {1}".format(host, err))
        # Print successful result
        try:
            print("{0} was {1}".format(result['hostname'], result['action']))
        except KeyError:
            print("NOTE: {0}".format(result['errors'][0].split('. ')[0] + '.'))

def unmute_host(hostname):
    # Initialize API for use and grab requestor
    dd_login = api_initialization(args.config)
    # Unmute the host by hostname
    for host in hostname.split(','):
        if host == "":
            continue
        try:
            result = api.Host.unmute(host)
        except Exception as err:
            raise SystemExit("Unable to unmute {0} due to: {1}".format(host, err))
        # Print successful result
        try:
            print("{0} was {1}".format(result['hostname'], result['action']))
        except KeyError:
            print("NOTE: {0}".format(result['errors'][0]))

def create_downtime(scope, FOREVER=False, ENDHOURS=2):
    # Initialize API for use and grab requestor
    dd_login = api_initialization(args.config)
    # Check arguments
    if args.forever:
        FOREVER=True
    if args.hours is not 2:
        ENDHOURS=args.hours
    # Create downtime
    if FOREVER:
        try:
            result = api.Downtime.create(scope=scope, message="scheduled by ddctl for {}".format(dd_login))
            if not result['active']:
                raise SystemExit("I don't show the downtime as active. Please investigate.")
            else:
                print("Downtime was successfully scheduled that will be in place until removed.")
        except Exception as err:
            raise SystemExit("There was an error adding downtimes: {0}".format(err))
    else:
        try:
            result = api.Downtime.create(scope=scope, end=hours_from_now(ENDHOURS), message="scheduled by ddctl for {}".format(dd_login))
            if not result['active']:
                raise SystemExit("I don't show the downtime as active. Please investigate.")
            else:
                print("Downtime was successfully scheduled.")
        except Exception as err:
            raise SystemExit("There was an error adding downtimes: {0}".format(err))

def get_downtimes():
    # Initialize API for use and grab requestor
    dd_login = api_initialization(args.config)
    # List downtimes owned by you
    if args.list_my_downtimes and args.list_all_downtimes == "_empty_":
        try:
            result = api.Downtime.get_all(current_only=True)
        except Exception as err:
            raise SystemExit("Unable to get your downtimes due to: {0}".format(err))
        print("Downtimes created by {}:".format(dd_login))
        count = 0
        for downtime in result:
            if downtime['message'] is not None \
                and downtime['message'].split()[-1] == dd_login:
                count += 1
                print("Scope: '{scope}' has id: {id}"
                    .format(scope=downtime['scope'],
                    id=downtime['id']))
        if count == 0:
            print("None.")
    # Get all downtimes
    if args.list_all_downtimes and args.list_my_downtimes == "_empty_":
        try:
            result = api.Downtime.get_all(current_only=True)
        except Exception as err:
            raise SystemExit("Unable to get all downtimes due to: {0}".format(err))
        if len(result) > 0:
            for downtime in result:
                print("Scope: '{scope}', Monitor: '{mon}' has id: {id}"
                    .format(scope=downtime['scope'],
                    mon="-" if downtime['monitor_id'] is None else \
                        api.Monitor.get(downtime['monitor_id'])['name'],
                    id=downtime['id']))
        else:
            print("There are no current downtimes.".format(dd_login))
            raise SystemExit(0)

def remove_downtime(id):
    # Initialize API for use and grab requestor
    dd_login = api_initialization(args.config)
    # Delete the downtime
    try:
        api.Downtime.delete(id)
    except Exception as err:
        raise SystemExit("Ran into an issue removing downtime '{id}': {err}".format(id=id, err=err))
    # Confirm the downtime was deleted
    try:
        result = api.Downtime.get(id)
        if result['active']:
            raise SystemExit("ERROR: I still show the downtime as active for {id}.".format(id=id))
        else:
            print("Downtime monitor delete request was successful.")
    except Exception as err:
        raise SystemExit("Ran into an issue confirming downtime delete was successful: {err}".format(id=id, err=err))

def search_for_host(query, CSV=False):
    # Initialize API for use
    dd_login = api_initialization(args.config)
    # Search for host by keywords
    try:
        result = api.Infrastructure.search(q='hosts:{0}'.format(query))
    except Exception as err:
        raise SystemExit("Unable to complete query {0} due to: {1}".format(query, err))
    # Print successful result
    if args.csv:
        CSV=True
    if CSV and len(result['results']['hosts']) > 1:
        print(",".join(sorted(result['results']['hosts'])))
    else:
        for host in sorted(result['results']['hosts']):
            print(host)

def get_all_tags():
    # Initialize API for use
    dd_login = api_initialization(args.config)
    # Return all tags in environment in json blob
    try:
        result = api.Tag.get_all()
        for tag in sorted(result['tags']):
            print(tag)
    except Exception as err:
        raise SystemExit("Unable to get all tags due to: {0}".format(err))

def get_tags_by_host(host):
    # Initialize API for use
    dd_login = api_initialization(args.config)
    # Return all tags in environment in json blob
    try:
        result = api.Tag.get(host)
        for tag in sorted(result['tags']):
            print(tag)
    except Exception as err:
        raise SystemExit("Unable to get tags for host {0} due to: {1}".format(host, err))

def _main():
    if len(argv) < 2:
        parser.print_help()
        raise SystemExit(1)

    if not args.host_query == "_empty_":
        search_for_host(args.host_query)

    if not args.get_all_tags == "_empty_":
        get_all_tags()

    if not args.tags_by_host == "_empty_":
        get_tags_by_host(args.tags_by_host)

    if not args.list_my_downtimes == "_empty_":
        if args.list_all_downtimes == "_empty_":
            get_downtimes()
        else:
            raise SystemExit("ERROR: Only expecting 1 downtime question at a time")

    if not args.list_all_downtimes == "_empty_":
        if args.list_my_downtimes == "_empty_":
            get_downtimes()
        else:
            raise SystemExit("ERROR: Only expecting 1 downtime question at a time")

    if not args.add_downtime == "_empty_":
        if args.scope == "_empty_":
            raise SystemExit("Scope argument is required when addding downtime")
        create_downtime(args.scope)

    if not args.remove_downtime == "_empty_":
        if args.id == 0:
            raise SystemExit("delete downtime argument requires a valid id argument")
        remove_downtime(args.id)

    if not args.mute == "_empty_":
        if args.host == "_empty_":
            raise SystemExit("mute argument requires a host argument")
        mute_host(args.host)

    if not args.unmute == "_empty_":
        if args.host == "_empty_":
            raise SystemExit("unmute argument requires a host argument")
        unmute_host(args.host)

if __name__ == '__main__':
    _main()
